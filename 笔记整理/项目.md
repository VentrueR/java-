# 分库分表

## 场景

根据用户ID对活动明细、用户明细做了分库分表

定时任务只做了分表

# 设计模式

## 场景

### 工厂模式

设计一个工厂类，配置接口map和Repository统一管理和实现工厂功能

策略责任链（黑名单、权重、默认，根据规则遍历）

活动责任链（活动（状态、时间、库存）校验、活动sku库存扣减）

上述都直接返回责任链

组合树（返回责任引擎类）

### 策略模式

Map注入自动装配bean和接口实现类

### 责任链模式

1. 定义责任链装配接口，定义获取next链和连接next链的方法
2. 链继承链装配，实现链的执行
2. 定义抽象链，定义next链节点，重写方法

活动责任链：检验、库存扣减，直接连接实现类再执行

策略责任链：遍历策略规则表的rule_model，用这个key get实现类，连接实现类

### 组合模式

1. 设计决策树、决策树节点、以及决策树分支的库表。
2. 决策树工厂，执行方法返回决策树引擎
3. 实现决策树节点（次数锁、扣库存、兜底）
4. 使用决策树引擎前，组装决策树->(map)树节点->（list）树链
5. 从树根节点开始向分叉，比较数据库放行情况和节点设计放行情况同时相等则树节点沿着分叉走下去
6. 数据库是次数锁到库存放行，到兜底接管、库存到兜底放行

# 部署

本地构造前后端镜像

1. 本地 docker desktop创建容器使用
2. Push到Docker Hub，再编写docker compose脚本云服务器部署

# 值对象和实体对象的设计

前者用于无唯一id，不影响数据变化。后者相反。

设计了数据库字段枚举，流程属性值，规则树的vo，延迟队列的vo

# 印象最深刻的bug

早期策略抽奖设计，一是数据未装配执行抽奖，后端服务器大量报错。其次是设计组合树，连接匹配。

直接decr，自动初始化缓存为0，把缓存直接扣减成-1，忘记判断返回false，从而错误添加延迟队列，定时任务消费报错，夹杂其他报错。通过层层断点，调试预期变量是否符合。

# 抽奖前、中、后做了什么

前：人群过滤，预热

中：库存扣减、n积分解锁、n次抽奖

后：兜底奖励

# 库存扣减、最终一致性

数据库会加锁，所以用redis分段锁缓存、延迟队列或mq、mq清空、任务补偿

incr从0开始向上加库存，区别decr主要解决了要加库存的情况。

# 分布式特性

视频整理。