# 前言

Java程序中，由JVM自动管理内存泄漏和溢出问题。



## 1.JVM内存模型（jdk1.8）

### 线程共有

#### 堆

##### 介绍

主要存储对象实例和数组，jdk1.7逃逸分析：引用没有返回和没有被使用 创建在栈中

GC堆，垃圾收集工作的主要地方

##### 组成

新生代 老年代 永久代

##### 年龄阈值

为什么只有0~15岁？

##### 异常

OOM GC回收超时和内存不足

#### 字符串常量池

##### jdk1.7为什么要移动？

GC回收效率低，需要FullGC

#### 方法区（废除）

##### 介绍

存储虚拟机加载的类、字段、方法、常量、静态变量等数据

##### 方法区 永久代 元空间的关系？ 

接口 实现类

##### 为什么废除方法区

1. 在方法区时受JVM内存影响，到元空间后受本地内存影响
2. 合并HotSpot JRockit,后者没有永久代
3. GC回收效率提高

### 线程私有

同：生命周期和线程相同

#### 程序计数器

##### 介绍

是一块内存地址。

##### 作用

1. 字节码解释器 通过它 读取指令 控制代码流程
2. 多线程中 切换线程后 通过它 找到当前线程执行位置

##### 唯一无OOM

#### Java虚拟机栈

##### 介绍 

除了Native方法的所有Java方法都在此栈中实现

##### 栈帧

生命周期和方法相同（方法执行来记忆）

###### 局部变量表 

基本数据类型变量和引用变量

###### 操作数栈

存放方法计算的中间结果和临时变量

###### 动态链接

运训常量池中方法的符号引用转换成内存的直接引用(递归)

###### 方法返回地址

地址

##### 异常

SOF	栈内存不能动态扩展，超栈深度

OOM 栈内存能动态扩展，超内存空间

#### 本地方法栈

##### 介绍

实现Native方法

##### 栈帧和异常

### 本地内存

#### 元空间

##### 运行时常量池

​	class文件 存类、字段、方法、接口等信息和常量池表

###### 介绍

类加载后存储常量池表

​	常量池表 字面量（知道值时什么类型）和符号引用（类、字段、方法、接口）

###### 异常 

OOM

#### 直接内存

#### 介绍

一块内存缓冲区

NIO通过管道和缓冲区的IO方式，用Native函数库分配堆外内存，在DirectByteBuffer上操作。避免Java堆和Native堆来回复制

#### 异常

OOM

### 版本补充

#### jdk1.7之前 

字符串常量池和静态变量在方法区（线程共有）

#### jdk1.7 

~移动到堆 

运行时常量池在永久代内

#### jdk1.8

方法区就是元空间（直接内存）

运行时常量池在元空间内





