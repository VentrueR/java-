# 前言

Java程序中，由JVM自动管理内存泄漏和溢出问题。



## 1.JVM内存模型（jdk1.8）

### 线程共有

#### 堆

##### 介绍

主要存储对象实例和数组。

jdk1.7开启逃逸分析：引用没有返回和没有被使用 创建在栈中

GC堆，垃圾收集工作的主要地方

##### 组成

新生代 老年代 永久代

##### 年龄阈值

为什么只有0~15岁？

##### 异常

OOM GC回收超时和内存不足

#### 字符串常量池

##### jdk1.7为什么要从永久代移动？

GC回收效率低，需要FullGC

#### 方法区（废除）

##### 介绍

存储虚拟机加载的类、字段、方法、常量、静态变量等数据

##### 方法区 永久代、元空间的关系？ 

接口 实现类

##### 为什么废除方法区

1. 在方法区时受JVM内存影响，到元空间后受本地内存影响
2. 合并HotSpot JRockit,后者没有永久代
3. GC回收效率提高

### 线程私有

同：生命周期和线程相同

#### 程序计数器

##### 介绍

是一块内存地址。

##### 作用

1. 字节码解释器 通过它 读取指令 控制代码流程
2. 多线程中 切换线程后 通过它 找到当前线程执行位置

##### 唯一无OOM

#### Java虚拟机栈

##### 介绍 

除了Native方法的所有Java方法都在此栈中实现

##### 栈帧

生命周期和方法相同（方法执行来记忆）

###### 局部变量表 

基本数据类型变量和引用变量

###### 操作数栈

存放方法计算的中间结果和临时变量

###### 动态链接

运行时常量池中方法的符号引用转换成内存的直接引用(递归)

###### 方法返回地址

地址

##### 异常

SOF	栈内存不能动态扩展，超栈深度

OOM 栈内存能动态扩展，超内存空间

#### 本地方法栈

##### 介绍

实现Native方法

##### 栈帧和异常

### 本地内存

#### 元空间

##### 运行时常量池

​	class文件 存类、字段、方法、接口等信息和常量池表

###### 介绍

类加载后存储常量池表

​	常量池表 字面量（知道值时什么类型）和符号引用（类、字段、方法、接口）

###### 异常 

OOM

#### 直接内存

#### 介绍

一块内存缓冲区

NIO通过管道和缓冲区的IO方式，用Native函数库分配堆外内存，在DirectByteBuffer上操作。避免Java堆和Native堆来回复制

#### 异常

OOM

### 版本补充

字符串常量池，方法区-》元空间（运行时常量池跟着走）

#### jdk1.7之前 

字符串常量池和静态变量在方法区（线程共有）

#### jdk1.7 

~移动到堆 

运行时常量池在永久代内

#### jdk1.8

方法区就是元空间（直接内存）

运行时常量池在元空间内



### 堆和栈的区别

用途：

内存空间：

共享性：

速度：前者慢，回收多/后者快

生命周期：回收决定/方法调用

### 引用类型

强

软

弱

虚

## 类加载机制

### 创建对象的过程

**检查（符号引用）** -》 分配内存 -》 初始化0（内存空间）-》**必要设置对象头**（是哪个类实例，GC代年龄）-》init方法

### 类加载器

启动类~、拓展~，应用程序~

核心库/jar包/自己编写的

### 双亲委派

#### 是什么

完成加载

类加载器之间，请求父加载器，最终交给最顶层启动类加载器，无法完成再由子加载器去完成

### 作用

唯一、安全、隔离、简化

避免重复加载（唯一）

### 类加载过程

//加载（全限定名）、连接（验证/准备/解析）、初始化、使用、卸载

## 垃圾回收 

### 是什么？怎么触发？

jvm自动管理内存的机制。

内存不足，自动/手动/调参/监控阈值

### 判断垃圾

引用计数：每次引用+1为0清空（循环引用不清空）

可达性分析：垃圾收集根出发，所有可达引用（不可达被回收）

### 垃圾回收算法

标记清除： 基于可达性 -》效率低、碎片化

复制：分成两块，用一块，不够则复制到另一块，清楚旧块。

是为了解决碎片问题。（利用率不足）

标记整理：复制gc少，老年代中没gc的对象存活多，一样去标记，整理存活的到一端、另一端清除

分代回收：新生代每次GC存活+1到默认阈值15，老年代

### 垃圾回收器

Serial/Serial Old 新生代老年代串行回收（响应速度优先）

ParNew/Parallel Scavenge/Parallel Old 并行（吞吐量优先）

CMS 老年代并行收集，响应速度优先

G1 并发，并行回收整个堆，速度优先

### young/old/full GC特点和场景

新生代：只，频繁且快，空间不足触发

老年代：主要，少且慢，空间不足触发

整个堆：空间不足/主动/新生代转老年代空间不足/元空间不足

full gc会停下所有工作线程，需减少

### CMS和G1区别/使用场景

用途：老年/堆

垃圾回收算法、回收过程：标记清除/标记整理 -》 碎片

CMS有浮动垃圾



速度/区域/碎片要求

### G1特点

分区/优化：停顿时间可控/标记整理/并行并发

## 吞吐量

### 是什么

单位时间的处理工作量

qps：每秒处理请求数量

tps：每秒事务处理数量

bps：每秒比特数量（网络传输）



