## 滑动窗口

1. 不重复最长字串：滑动同时前面的全删2O(n)
2. 字符串所有异位词：取巧不用完全equals，计数判断

## 哈希

1. 两数之和：要考虑排序，自定义类排序或哈希
2. 异位词分组：对标准排序，哈希
3. 最长连续序列：判x-1是否存在，只遍历HashSet

## 字串

1. 和为K的子数组：前缀和性质s[i]=s[j]-k，枚举，注意0
2. 滑动窗口最大值：维护递减队列，更新队尾
3. 最小覆盖字串：滑动窗口（变形），判有效个数

## 双指针

1. 移动0：0计数，其他的往前放
2. 盛最多水的容器：两边最高（贪心）
3. 三数之和：排序，双指针i/l/r
4. 接雨水：当前列由左和右最高高度决定

## 链表

1. 相交链表：互相保证走同样长度，会同步移动，地址相同则相交
2. 翻转链表：递归，记得next清null
3. 回文链表：简单直接取出来比，o1空间快慢指针+一半翻转
4. 环形链表：有环一定交叉
5. 环形链表2：求进入的交点o1空间，数学推导，相遇后head到环的步数和相遇到起点的步数一致
6. 合并两个有序链表：类似归并排
7. 两数相加： 高精度加法
8. 两两交换链表节点：新头节点，三个节点都要考虑
9. K个一组翻转：新头节点，模拟k个一起翻转st~ed，k为1特判
10. 随机链表复制：随机不方便存顺序，全部用哈希表映射来做。
11. 排序链表：快慢指针找中点，拆且组，归并排序
12. 合并k个升序链表：直接小根堆（拆顺序），分治两次
13. LRU缓存，双向循环链表+Map（直接LinkedHashMap简单。）（模拟）

## 二叉树

1. 中序遍历：递归简单，迭代考虑栈
2. 二叉树的最大深度：递归MAX+1
3. 翻转二叉树：后序遍历，交换
4. 对称二叉树：递归左右树，对称比较+特判空情况
5. 二叉树的直径：动态规划，递归顺序返回子树大一边，答案是左子树和右子树之和
5. 二叉树层序遍历：取size队列bfs就可以层序了
5. 将有序数组转换为二叉树：直接递归，分割中点/左/右，就满足平衡条件了。
5. 验证二叉搜索树：存min/max状态，来判断节点要小于左子树最小值/~，要判到空节点（222的情况），要long（int可以取最大，边界取Int就会相等类似222）
5. 二叉搜索树中第 K 小的元素：中序遍历计数
5. 二叉树的右视图：bfs最后出队
5. 二叉树展开为链表：不考虑空间，直接前序重新构造就行，空间O(1)后序遍历，左接右，再接右递归处理
5. 前序中序构造二叉树：哈希表+确定顺序，递归处理
5. 路径总和：和子数组K同解法，树得话只要遍历一条边map存求和，记得回溯
5. 最近公共祖先：直接递归，找到节点则返回，左右子树都不空返回根节点，一者为空则返回非空子树
5. 二叉树最大路径和：直接，正常递归返回链（一条边），答案是u+l+r（因为null传上来的链最差情况会被0替代）

## 数组

1. 最大字数组和：直接dp取max
2. 合并区间：需要排序，cr取max
3. 轮转数组：全部翻转，翻转前k和后k
4. 除自身外数组的乘积：因为有一个0的情况比较特殊，维护前后缀乘积就可以解题
5. 缺失的第一个正数

## 动态规划

1. 爬楼梯：dp
2. 杨辉三角：模拟
3. 打家劫舍：状态机Dp
4. 完全平方数：完全背包
5. 零钱兑换：完全背包，continue处理-1边界不转移的，第一次必转移的
6. 单词拆分：直接dp 或者 n方hash
7. 最长递增子序列：一定要判条件（明白过程的各种可能出现的状态）
8. 乘积最大子数组：和子数组和同性质，要维护负数即可
9. 分割等和子集：存在sum/2且sum为偶数
10. 最长有效括号：栈（处理前导')'考虑栈先加入下标，后续为空都补充）

## 多维动态规划

1. 不同路径：直接dp结果
2. 最小路径和：直接dp结果，注意边界
3. 最长回文字符串：马拉车(O(n))，动态规划dp{l}{r}l到r是回文串，判断相等中，3格内都可以直接认为是回文的，其他的转移
3. 最长公共子序列：dp{i}{j}第i位之前的a序列 和 第j位之前的b序列 中的最长公共子序列长度。
3. 编辑距离：dp{i}{j}第i位之前 变成 第j位之前 的权重，增/删/改dp{i-1}{j-1}来

## 贪心

1. 买卖股票的最佳时机：倒序维护最大值 做差就是结果/ 也可以正序维护最小值
2. 跳跃游戏：判断本次行动是不是 <= 能到的最远距离，且还没到终点 则无法到达
3. 跳跃游戏II：维护一个dp次数数组来求次数(用一个ed来加速能到的最大距离)
4. 划分字母区间：维护字母的最远距离，每次到边界取一次答案

## 二维数组

1. 矩阵置0：空间mn 或 m+n标记状态来解决
2. 
