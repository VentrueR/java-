## 1.JWT

token技术

### 包含

头（令牌类型、签名算法）Base64编码解密

载核（消息体非敏感信息）Base64编码解密

签名（公钥解密）

### RAS算法

一个公钥一个私钥

加解密，用公钥加密

签名用私钥签名

## 2.幂等性

### 解释

多次操作结果唯一

### 解决

全局唯一ID：雪花算法

1. （写库）数据库全局唯一id为主键（或校验）
2. （更新库）乐观锁（版本管理）
3. （全局ok）redis缓存token（作为全局唯一ID）
4. （微服务）上游服务从下游取（短时间不重ID）并缓存

token作为登录，具体业务代码细节加锁，舍弃性能来保证

作为唯一ID，业务中token先删后删，一般先删，后删考虑加锁阻塞或者redis乐观锁

## 3.消息队列

### 模型

发布-订阅、点对点

生产者，发送，消费队列，消费者根据主题消费

### 中间件

服务于应用软件，用户不接触

### 作用

异步、削峰、解耦、顺序、延时定时处理

### 带来的问题

MQ消息丢失、宕机

MQ重复消费、消息顺序

一致性

### 死信队列

#### 情况

消息在队列中死信，被重新发送到DLX交换器接管

#### 原因

消息被拒、过期、队列已满

### RabbitMQ

#### 工作

交换器接管生产者消息，结合发来的路由key和自身类型、bindingkey 路由到队列

#### 交换机类型

fanout 根据路由广播

direct 完全匹配key

topic 支持模糊匹配

header 消息请求头匹配（性能不高不常用）

#### 延迟队列

基于死信队列和TTL

#### 消息可靠（丢失）

生产者到MQ：confirm消息确认机制（任务队列监听，ack和nack）

//或事务

自身：持久化（存磁盘）、集群

MQ到消费者：ACK机制，消费完成后发送ACK 自动/手动（防止重复消费）

死信队列、补偿



#### 消息堆积

1. 消费者
2. 队列/死信队列
3. 消费速度
4. 网络故障监控



#### 消息重复消费

场景：接口没做幂等处理 -》 重复消息，消费者或者mq挂了

解决：数据库唯一约束，乐观锁，检验记录/消费表



## 4.雪花算法

符号位1、时间戳41、机械码10、序列号12

同一毫秒同一机械生成2^12



时序号

## 5.XXL-job

分布式调度任务

## 6.降级、熔断、限流

引入zk，配置zk客户端，创建路径并监听。

(路径已创建情况)

降级：自定义注解，通过实现BeanPostProcessor，重写初始化后的方法取注解中的value，返回Map<路径，字段>给zk客户端，zk监听根据map动态反射更新



熔断：设置字段value，命令执行超时时间



限流：自定义注解，key、failMethod、cnt、limit

Aop guava库 24小时黑名单 1分钟限频Cache



黑名单>注解次数

put(,Ralimit persecond)

更新黑名单访问+1

## 7.负载均衡

正向代理：代理客户端，向服务器请求并响应回去

反向代理：代理服务器，代理服务器接受请求，负载均衡给后端服务器

## Docker

容器



镜像/仓库/容器

build dockerfie(添加jar包)

本地仓库（desktop)/云端（dokerhub）

容器再从仓库拉取应用

## 云服务器

分配公网ip，（doker,portainer）根据端口部署应用

## ssh工具

terminus连接公网，操作centos7linux操作系统
