# Redis

## 介绍

是NoSql数据库（非关系型），数据存储在内存，读写非常快，内置多种数据结构，支持事务、持久化、Lua脚本、发布订阅、集群。用于分布式缓存技术。

## 为什么快

1. 基于内存存储，相对磁盘快
2. 单线程事件循环、IO多路复用
3. 内置数据结构
4. //通信协议简单、解析高效RESP

## 为什么用

高性能：为什么快

高并发：qps是mysql的十倍

## 其他分布式缓存方案

### Memcached


#### 共同点

基于内存、有过期策略、性能高

#### 不同点

redis介绍的优点

## 数据结构

### 五基本

### String 

#### 场景

序列化后对象、计数、分布式锁、session

#### 底层实现

SDS

len alloc flag buf



//简单动态字符串



相比C字符串，

1. 取长度O(1)，
2. （兼容"\0"）API用的处理二进制数据的方式， 保存文本和二进制数据（音视频文件），
3. 避免缓冲区溢出（动态扩容）

### List

#### 场景

 消息队列

#### 底层实现

双向队列或压缩列表。3.2后quicklist取代

列表元素个数小于默认值512，元素值小于默认值64字节为压缩队列。

### Hash

#### 场景

购物车

#### 底层实现

压缩列表或哈希表

规则同List。

7.0后listpack取代压缩列表

### Set

#### 场景

 聚合计算（点赞、关注、抽奖）

#### 底层实现

整数集合或哈希表

都小于512为前者

### ZSet

### 场景

 排行榜

#### 底层实现

压缩列表或跳表

128 64

7.0listpack替代前者

#### 跳表

##### 查找方式

最高层、当前节点和目标节点权重，小于访问下一个节点。等于则比较SDS小于访问下一个节点。

##### 层级设置

相邻层节点控制在2:1，实际每次new 层走Random小于四分之一则加层，不超过64层

##### ZSet为什么不用其他数据结构

平衡二叉树、红黑树 

内存占用/范围查询/算法实现

B/B+树

数据体量

#### 压缩列表

连续内存块，顺序型数据结构

首位节点访问O(1)，其他O(n)



连锁更新：//大于254字节

放在头，记录前一个节点的长度的都要重新空间分配

#### quickList 和 ListPack

前者节点结构设计，减少了连锁压力

后者去除设计，记录当前节点长度，完全解决连锁更新

### 四新

BitMap 二进制信息

HyperLogLog 基数统计

GEO 地理信息

Stream 新消息队列（相对list队列，自动生成全局唯一消息ID，支持消费组）

### 哈希表扩容

rehash：表1，表2 = 2*表1空间，分配空间，数据迁移，释放表1，表2设置为表1，创建新表准备下次rehash

渐进式rehash：redis中优化，避免阻塞，操作的过程中，就在按顺序数据迁移，具体。。

## 单线程模型

### 多线程

客户端请求-》解析请求-》命令操作 -》 响应数据 这个过程是单线程的



它的多线程体现在：

后台线程：

释放文件资源：AOF/RDB产生的临时文件

刷盘AOF：系统内核缓冲区未同步到磁盘，强制刷盘

lazyfree线程，释放内存：删除大Key

6.0之后 增强网络IO读写（性能瓶颈），响应多线程，默认只有发送响应数据多线程，读请求多线程需要配置//（IO多路复用）



单线程会阻塞，影响效率



### 怎么实现IO多路复用

非阻塞 socket通信

监听事件 监听io/channel事件

文件事件处理器/多路复用程序

Reactor模式：在一个进程内完成，把事件分配给相应事件处理器

### 网络模型

6.0前 单Reactor单线程的模式

6.0后 多线程I/O



## 持久化

### AOF

#### 是什么

AOF文件记录了写操作命令日志

#### 底层实现，为什么

redis先执行写操作，再写入AOF日志

具体一些：写操作后，写入到AOF缓冲区，由I/O系统写入内核缓冲区，最后由内核根据写回策略写回磁盘（重写机制）(这里可以把所有串起来)



防止错误写入AOF，检查开销

防止阻塞写操作，但也带来了数据丢失、写入AOF时有一定阻塞

#### 写回策略

永久 每次写都存日志 性能差、数据几乎不丢失

每秒 延时存日志 ...

从不 操作系统统一存日志 ...

#### 日志过大重写机制

AOF过大，创建新的AOF，重写最新操作并且覆盖



如set key value 覆盖命令，可以合并来减少开销

#### 重写AOF文件过程以及会阻塞主进程吗

开一个新的子进程去重写AOF



不阻塞主进程，不用像多线程担心加锁的安全问题

写时复制不阻塞，是因为有重写缓冲区，写操作后，会写入缓冲区和重写缓冲区。重写AOF子进程完成后，异步发信号函数把重写缓冲区追加到新AOF文件，并覆盖旧文件

### RDB

#### 是什么

RDB是二进制内存数据，是实际的数据，内存可直接读入

#### 创建RDB文件

save bgsave区别在于实在主线程还是子线程创建RDB文件

全量快照，存内存时刻所有信息到磁盘，次数多影响性能，次数少数据丢失

#### 影响主进程吗

不影响，写时复制技术，bgsave 执行fork()，创建子线程，保存父进程页表，指向同一块物理地址，主进程修改时，拷贝一份副本数据

### 混合持久化

开启混合持久化后，AOF重写时，把RDB文件也写入到AOF文件。AOF文件中既有RDB也有原AOF

优点：AOF数据丢失少，恢复慢，RDB容易丢失，恢复快，两者刚好兼容

缺点：AOF文件可读性变差，与4.0之前（旧AOF）不兼容

## 集群

### 主从集群

一般一台主服务器，多台从服务器

主服务读写，从服务器只读，异步从主服务器数据同步

### 哨兵模式

监测主服务器和从服务器，提供故障转移功能

### 切片集群

减少一台服务器缓存大量数据的压力，采用哈希槽映射具体redis节点

### 脑裂

主服务器和从服务器还没完全同步时，主服务器故障（网络），哨兵模式把主服务器降级，选新的主服务器，故障恢复，主服务器清空本地数据，全量同步，数据丢失。

解决：主节点和从节点无法通信 或 设置小于通信阈值则主节点不再继续写操作，直接返回错误

## 过期删除与内存淘汰

### 删除策略

expire存在过期字典中。采用懒删除和定期删除。

#### 懒删除

需要访问的时候，查是否过期，过期则删除

优点：减少cpu负担

缺点：额外占用内存

#### 定期删除

从过期字典随机取20个key检验是否过期，删除过期，超过四分之一则反复执行，默认不超过25ms

优点：缺点：

### 内存淘汰

默认不淘汰，直接返回错误。

淘汰...

#### LRU 

Recent

最近最少使用（时间）

传统使用链表，队头最常用

Redis对象中添加了一个最后访问时间字段，采取随机采样淘汰，任然会有随机不到污染问题。

内存开销小，性能好。

#### LFU

Frequency

最近最不常用（访问次数）

对象头lru字段高16位记录时间戳低8位记录次数

## 缓存设计

### 缓存穿透

数据库和redis中都不存在

解决：布隆过滤器（布谷鸟过滤器支持删除元素），缓存null或默认值，参数校验非法请求

### 缓存雪崩

redis中大量缓存失效

解决：随机失效时间、不失效

### 缓存击穿

热点数据失效

解决：互斥锁setNx、不失效

### 缓存热点数据

最新访问时间排序，例如topk，定期k尾部的更新

### 缓存更新策略

先更新库还是缓存 -》 更新后先删还是后删

#### 旁路缓存

更新数据库同时更新缓存

适合读多的场景



读策略：有则返回,没有则读库，缓存

写策略：先更新数据库，再删缓存

因为反过来，场景：写操作间穿插读操作，会出现缓存和数据库不一致

原来来说，场景：读操作中穿插写操作，并发+缓存失效+写缓存之前有读操作

#### 读穿 / 写穿

不先走db，先走缓存来交互数据库（适合本地缓存）

#### 写回

适合写多的场景

更新的时候，只做Reids操作，其他线程异步来持久化数据库响应数据最终一致性

# 缓存与数据一致性

旁路策略，适合读多的业务，先更新数据库再删缓存，解决大部分。

删缓存操作失效，(mq)发消息队列去异步重试 或 订阅binlog日志再操作缓存（cannal）



集群：

先删缓存再更新数据库，读写分离主从复制延迟，延时双删除，延时时间大于读操作完毕时间 大于主从复制时间。



要求缓存命中率高，也可以更新数据库，更新缓存，加分布式锁，缓存较短的延时时间

## redis实战

### 延迟队列

可以用有序集合zset，add score设置延迟时间，zrangebyscore循环执行队列任务

### 大key

是value很大，带来阻塞和内存分布不均。

可以查看和删除。

### 管道

批量执行命令和返回结果。避免命令之间等待

### LUA脚本

操作原子性，减少网络交互，持久化可复用

### redis事务

不支持回滚

### 自旋锁

间隔时间循环等待锁释放（不停）

优：不阻塞（相对互斥锁），适合非竞争

缺：竞争，浪费Cpu资源

### 分布式锁

唯一lockkey +set nx +ex过期时间

简单，高效，解决分布式部署问题。

缺点：注意过期时间设置，集群主从复制下出问题，引入红锁，连接多个主节点，一半以上获取锁成功，则从节点获取分布式锁

# Redisson

## 是什么

基于Redis实现分布式服务的框架

## 区别

### 可重入

多次获取同一把锁

源码的异步获取锁和异步释放锁的Lua脚本，redis缓存hash结构，每获取就value+1，释放value-1,为0删除缓存，发布消息

### 可重试

tryLock

最大等待时间 - 尝试获取锁时间 - 收到订阅时间  + for(-尝试获取锁时间 - 订阅获取信号量时间)

直到获取到锁或者最大等待时间《=0



### 超时释放

trylock（非阻塞，最大等待）  lock（阻塞）

#### 看门狗（异步获取锁 自动设置的超时释放时间leaseTime）

trylock -> tryAcquire尝试获取锁 get异步获取锁，如果没有设置超时施放时间leaseTime，自动设置看门狗时间30s，异步执行获取锁

#### 刷新锁的延时时间

异步获取锁成功返回null，执行schedule函数，static final concurentMap 存key entryName 和value entry，添加线程Id（可重入)

entryName由连接id+lockName组成，所以同一线程 对应一把锁 对应一个entry

第一次创建entry，递归执行刷新延时为1/3的超时施放时间的 过期时间任务



释放锁取消定时任务 -》 取entry -》移除线程ID -》 关闭递归任务 -》 移除Map的entryName



失败返回锁释放时间pttl（ms）

### 主从一致性

multiLock，连接多个redis节点作为主节点。

waitTime -1不重试

所有获取重入锁才算成功





