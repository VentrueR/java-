# 硬件结构

## 冯诺依曼模型

### 组成

存储器、运算器、控制器、输入输出设备

### 总线

#### 组成

地址总线：指定cpu指令地址

数据总线：读写内存数据

控制总线：接收和发送信号

#### 作用

cpu和存储器以及其他设备连接通信

## 程序基本执行过程

## 进程管理

#### 区别

本质/包含/分配内存/切换开销/稳定性/通信不同

#### 进程

操作系统资源分配的基本单位（虚拟内存，文件句柄，信号量等）。

独立堆、栈（内存空间）。

上下文切换开销大

（隔离/独立）



程序执行的一次过程就是进程，是操作系统资源（内存，文件、信号量）分配基本单位

#### 线程

任务调度和执行的基本单位。

共享进程内存空间（独立栈/计数器）

上下文切换开销小



被进程包括，是进程中的一条执行流程，是cpu调度的单位



比较：定义、状态、共享资源、多线程（时间空间利用率）更高（体现在 - 》子：生命、切换、共享）



#### 协程

用户态轻量级线程，由用户控制，**开销更小/不走内核态**，直接保存/恢复协程上下文，不切换，用户自己显示控制（应对高并发）



#### 进程通信

共享内存、管道、信号、socket、消息队列、

#### 进程之下为什么要有线程

实现进程之间通信/减少进程开销

#### 死锁

互相等待对方释放锁



原因：

同时满足：互斥、持有等待、不可剥夺、环形



解决：

破坏第四个条件，常用资源有序分配法

#### 锁

##### 互斥、自旋锁

setNx，失败释放

忙等

##### 读、写锁

（公平读写锁）优先级任务队列

##### 乐观、悲观

觉得没冲突

觉得有冲突

#### 多线程和单线程优/劣

多线程充分利用多核处理，加速任务处理

带来线程安全问题，数据不对/死锁/消耗资源多

#### 多线程太多会怎么样

切换上下文开销大/死锁

#### 进程/线程切换差距在哪

进程需要切换整个**地址空间**/全局变量/文件描述符

#### 线程上下文信息存在哪

（用于切换）线程本身上下文信息，**寄存器，栈，程序计数器，指针**

#### 进程状态

就绪 -（时间片）》运行 - 》阻塞

#### 管道

流式传输



匿名管道：父子/兄弟进程通信

命名管道：无关进程通信（文件系统）

#### 信号和信号量

信号进程通信，一种处理异步事件的方式

信号量基于线程

#### 进程的上下文是什么/存在哪

用户空间虚拟内存，堆栈，全局变量，内核空间堆栈，寄存器

#### 共享内存怎么实现

不同进程**拿虚拟地址** 映射到**同一个**物理地址



#### 线程通信

互斥锁/信号量/条件/自旋锁/读写锁



#### 进程调度算法

先来（适用cpu繁忙）/最短作业/响应比（（等待+花费）/花费）/时间片/优先级

#### 银行家算法

判断：不负荷（不超过）/可分期（不用一次性）/延迟分配（可以等待）

**解决持有等待**

依次让所有线程进入安全队列

## 内存管理



### 用户态和内核态

前者权限低，后者高，访问硬件资源，cpu指令多

安全/隔离/稳定性

### 简单介绍？

进程通过虚拟内存和物理内存交互

### 页表 段表

MMU内存管理单元来辅助页表

页表存在内存，对虚拟内存 和 物理内存分页，根据页表来映射的（4kb）

也是用来映射的，包含堆/栈/数据/代码



#### fork复制了什么

父进程的虚拟内存，发生copy on write还复制物理内存



### malloc 1kb和1mb

C函数

分配128kb以内brk() -》 堆分配

以上内存 mmap() -》 	文件映射区



### 页面置换算法

发生在缺页异常（找不到物理内存），选择置换物理页

1. 未来最长时间（计算下一次）
2. 内存中停留最久
3. 最久没用
4. 时钟算法
5. 最不常用

## 网络I/O

### 有哪些I/O模型

### select/poll/epoll

进程-》i/o事件，是三个多路复用接口



多路复用中

socket放文件描述符集合

在内核态和用户态 遍历/拷贝文件描述符集合

交给用户处理



多路复用会 把已连接(可读/可写)socket存文件描述符集合

遍历描述符，并拷贝 -》 内核 (用户一次/内核一次)

-》传给用户处理



select：bitsMap(文件描述符个数限制)



poll：动态数组+链表（无限制）



上述O(n)



epoll：引入红黑树存（文件描述符），log(n)的取，（回调）存就绪事件链表



epoll_wait从链表拿到需要的，而不是前两者拿到全部



边缘触发：wait唤醒服务器一次/配合非阻塞i/o模型使用（不知道具体读写状况，出错再结束）

一次wait





水平触发：多次（开销影响）

多次wait



### redis，nginx，netty 是依赖什么做的这么高性能？

reactor模式，来一个事件就反应



redis：单reactor（未充分利用多核cpu/阻塞）

netty：多reactor（多线程）

nginx：多reactor（多进程，主进程初始化socket，子进程connect）



### 零拷贝

传统I/O

硬盘读数据，通过网卡向外发送。

需要四次切换/四次拷贝



 -> 为了提高文件传输效率，一次系统调用，合并磁盘读取和网络发送的操作（在内核中完成）







四次，硬件和内核出/入，内核和用户出/入

两次，sendfile()内核完成
